<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Meu Leitor de Livros</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6; /* Light gray background */
            display: flex;
            justify-content: center;
            align-items: flex-start;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
            overflow-x: hidden; /* Prevent horizontal scroll */
        }

        .main-app-container {
            background-color: #ffffff;
            border-radius: 1.5rem; /* Increased border radius for modern look */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); /* Stronger shadow */
            padding: 1.5rem; /* Reduced padding for mobile */
            max-width: 95%; /* Responsive max-width */
            width: 100%;
            min-height: 85vh; /* Minimum height for better layout */
            display: flex;
            flex-direction: column;
            position: relative;
            overflow: hidden; /* Hide overflow during view transitions */
        }

        /* --- Library View Styles --- */
        #library-view {
            display: flex;
            flex-direction: column;
            height: 100%;
            width: 100%;
        }

        .library-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding: 0 0.5rem; /* Adjust padding for mobile */
        }

        .add-book-button {
            background-color: #4f46e5; /* Indigo */
            color: white;
            border-radius: 9999px; /* Fully rounded */
            width: 50px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.8rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .add-book-button:hover {
            background-color: #4338ca;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15);
        }

        .add-book-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .book-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); /* More responsive grid */
            gap: 1rem; /* Spacing between book cards */
            flex-grow: 1;
            overflow-y: auto; /* Scroll for books */
            padding-right: 5px; /* Prevent scrollbar from overlapping content */
        }

        .book-card {
            background-color: #f9fafb;
            border-radius: 0.75rem; /* Rounded borders for cards */
            padding: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            cursor: pointer;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.05), 0 1px 2px -1px rgba(0, 0, 0, 0.03);
        }

        .book-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
        }

        .book-card-cover {
            width: 100px; /* Fixed width for covers */
            height: 140px; /* Fixed height for covers (aspect ratio for books) */
            object-fit: cover;
            border-radius: 0.5rem;
            margin-bottom: 0.5rem;
            border: 1px solid #e5e7eb; /* Light border */
        }

        .book-card-title {
            font-size: 0.875rem; /* Smaller text for mobile */
            font-weight: 500;
            color: #374151;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap; /* Prevent title wrapping */
            width: 100%;
            padding: 0 0.25rem;
        }

        /* --- Reader View Styles --- */
        #reader-view {
            display: none; /* Hidden by default */
            flex-direction: column;
            height: 100%;
            width: 100%;
            gap: 1rem;
            position: absolute; /* Allow transition from library */
            top: 0;
            left: 0;
            background-color: #ffffff;
            border-radius: 1.5rem;
            transition: transform 0.4s ease-out, opacity 0.4s ease-out;
            transform: translateX(100%); /* Start off-screen right */
        }

        #reader-view.active {
            display: flex;
            transform: translateX(0%); /* Slide in */
        }

        .reader-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            padding: 0 0.5rem;
        }

        .back-button {
            background-color: #6b7280; /* Gray */
            color: white;
            border-radius: 0.5rem;
            padding: 0.5rem 1rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .back-button:hover { background-color: #4b5563; }

        .current-book-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1f2937;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            flex-grow: 1;
        }

        #pdf-canvas, #text-content-display {
            display: block;
            width: 100%;
            height: auto;
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            background-color: #f9fafb; /* Light background for canvas */
            cursor: grab; /* Indicate draggable */
            transition: transform 0.3s ease-out, opacity 0.3s ease-out; /* Smooth transition for page turns */
            user-select: none; /* Prevent text selection during drag */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            flex-grow: 1; /* Allow content to grow */
        }

        #text-content-display {
            padding: 1rem;
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
            overflow-y: auto; /* Enable scrolling for text content */
            font-size: 1rem;
            line-height: 1.6;
            color: #374151;
            min-height: 300px; /* Ensure a minimum height for text content */
            resize: vertical; /* Allow manual resizing of text area */
        }

        .page-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 1.5rem;
            margin-top: 1rem;
            padding-bottom: 1rem; /* Add padding for mobile bottom */
        }

        .page-control-button {
            padding: 0.6rem 1.2rem; /* Smaller padding for mobile */
            background-color: #4f46e5; /* Indigo */
            color: white;
            border-radius: 0.75rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        .page-control-button:hover {
            background-color: #4338ca; /* Darker indigo */
            transform: translateY(-2px);
            box-shadow: 0 6px 10px -2px rgba(0, 0, 0, 0.15);
        }

        .page-control-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }

        /* --- Loading and Messages --- */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.9); /* More opaque */
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 1.5rem;
            z-index: 10;
            font-size: 1.2rem;
            font-weight: 600;
            color: #4f46e5;
            flex-direction: column;
            gap: 1rem;
        }

        /* Basic spinner */
        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-left-color: #4f46e5;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .message-box {
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #10b981; /* Green for success */
            color: white;
            padding: 15px 20px;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            opacity: 0;
            transform: translateY(-20px);
            transition: opacity 0.3s ease-out, transform 0.3s ease-out;
            z-index: 1000;
            max-width: 90%; /* Responsive width */
            text-align: center;
        }

        .message-box.show {
            opacity: 1;
            transform: translateY(0);
        }

        .message-box.error {
            background-color: #ef4444; /* Red for error */
        }
    </style>
</head>
<body class="relative">

    <div class="main-app-container">
        <!-- Loading Overlay (hidden by default) -->
        <div id="app-loading-overlay" class="loading-overlay hidden">
            <div class="spinner"></div>
            <p>Carregando...</p>
        </div>

        <!-- Library View -->
        <div id="library-view">
            <div class="library-header">
                <h1 class="text-3xl font-bold text-gray-800">Minha Biblioteca</h1>
                <label for="pdf-upload" class="add-book-button">
                    <i class="fas fa-plus"></i>
                </label>
                <input type="file" id="pdf-upload" accept=".pdf,.txt,.docx,.pptx">
            </div>

            <div id="book-list" class="book-list">
                <!-- Book cards will be injected here by JavaScript -->
                <div id="no-books-message" class="col-span-full text-center text-gray-500 text-lg py-10 hidden">
                    <p>Você ainda não tem livros na biblioteca. Clique no '+' para adicionar um!</p>
                </div>
            </div>
        </div>

        <!-- Reader View -->
        <div id="reader-view">
            <div class="reader-header">
                <button id="back-to-library-btn" class="back-button"><i class="fas fa-arrow-left"></i> Voltar</button>
                <h2 id="current-book-title" class="current-book-title"></h2>
            </div>

            <div class="relative flex flex-col items-center justify-center flex-grow">
                <div id="page-loading-spinner" class="loading-overlay hidden">
                    <div class="spinner"></div>
                    <p>Carregando página...</p>
                </div>
                <canvas id="pdf-canvas" class="w-full h-auto flex-grow"></canvas>
                <pre id="text-content-display" class="w-full h-auto hidden flex-grow"></pre>
            </div>

            <div class="page-controls">
                <button id="prev-page" class="page-control-button">Página Anterior</button>
                <span id="page-info" class="text-xl font-semibold text-gray-700"></span>
                <button id="next-page" class="page-control-button">Próxima Página</button>
            </div>
        </div>
    </div>

    <div id="message-box" class="message-box"></div>

    <!-- PDF.js CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js"></script>
    <script>
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

        // --- DOM Elements ---
        const mainAppContainer = document.querySelector('.main-app-container');
        const libraryView = document.getElementById('library-view');
        const readerView = document.getElementById('reader-view');
        const pdfUpload = document.getElementById('pdf-upload');
        const bookListContainer = document.getElementById('book-list');
        const noBooksMessage = document.getElementById('no-books-message');
        const backToLibraryBtn = document.getElementById('back-to-library-btn');
        const currentBookTitleDisplay = document.getElementById('current-book-title');
        const pdfCanvas = document.getElementById('pdf-canvas');
        const textContentDisplay = document.getElementById('text-content-display');
        const pageNumSpan = document.getElementById('page-info');
        const prevPageBtn = document.getElementById('prev-page');
        const nextPageBtn = document.getElementById('next-page');
        const appLoadingOverlay = document.getElementById('app-loading-overlay');
        const pageLoadingSpinner = document.getElementById('page-loading-spinner');
        const messageBox = document.getElementById('message-box');

        // --- Global State ---
        let books = []; // Array to store all books
        let currentBook = null; // The book currently being read
        let pdfDoc = null; // PDF.js document object
        let lastRenderPromise = null; // To prevent concurrent PDF rendering
        let isDragging = false;
        let startX = 0;
        const dragThreshold = 50; // Pixels to drag before considering a page turn

        // --- Utility Functions ---

        /**
         * Exibe uma mensagem flutuante para o usuário.
         * @param {string} message - A mensagem a ser exibida.
         * @param {boolean} isError - Se a mensagem é um erro, muda a cor de fundo.
         */
        function showMessage(message, isError = false) {
            messageBox.textContent = message;
            if (isError) {
                messageBox.classList.add('error');
            } else {
                messageBox.classList.remove('error');
            }
            messageBox.classList.add('show');
            setTimeout(() => {
                messageBox.classList.remove('show');
            }, 3000);
        }

        /**
         * Gera um UUID (Universally Unique Identifier) para IDs de livros.
         * @returns {string} Um UUID versão 4.
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0,
                    v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        /**
         * Mostra um overlay de carregamento em tela cheia.
         */
        function showAppLoading() {
            appLoadingOverlay.classList.remove('hidden');
        }

        /**
         * Esconde o overlay de carregamento em tela cheia.
         */
        function hideAppLoading() {
            appLoadingOverlay.classList.add('hidden');
        }

        /**
         * Mostra o spinner de carregamento da página no reader view.
         */
        function showPageLoading() {
            pageLoadingSpinner.classList.remove('hidden');
            pdfCanvas.classList.add('hidden');
            textContentDisplay.classList.add('hidden');
            prevPageBtn.disabled = true;
            nextPageBtn.disabled = true;
        }

        /**
         * Esconde o spinner de carregamento da página.
         */
        function hidePageLoading() {
            pageLoadingSpinner.classList.add('hidden');
            prevPageBtn.disabled = false;
            nextPageBtn.disabled = false;
        }

        /**
         * Salva o array de livros no Local Storage.
         */
        function saveBooksToLocalStorage() {
            try {
                localStorage.setItem('books', JSON.stringify(books));
            } catch (e) {
                console.error("Erro ao salvar livros no Local Storage:", e);
                if (e.name === 'QuotaExceededError') {
                    showMessage('Erro: Armazenamento local cheio. Limpe alguns livros ou tente um arquivo menor.', true);
                } else {
                    showMessage('Erro ao salvar o livro no armazenamento local.', true);
                }
            }
        }

        /**
         * Carrega o array de livros do Local Storage.
         */
        function loadBooksFromLocalStorage() {
            const storedBooks = localStorage.getItem('books');
            if (storedBooks) {
                books = JSON.parse(storedBooks);
            } else {
                books = [];
            }
            renderLibrary();
        }

        /**
         * Renderiza a biblioteca de livros.
         */
        function renderLibrary() {
            bookListContainer.innerHTML = ''; // Clear existing books
            if (books.length === 0) {
                noBooksMessage.classList.remove('hidden');
            } else {
                noBooksMessage.classList.add('hidden');
                books.forEach(book => {
                    const bookCard = document.createElement('div');
                    bookCard.className = 'book-card';
                    bookCard.dataset.bookId = book.id;
                    bookCard.onclick = () => loadBook(book.id);

                    const img = document.createElement('img');
                    img.className = 'book-card-cover';
                    // Use a placeholder image for unsupported types or if cover generation failed
                    img.src = book.cover || getGenericCover(book.type);
                    img.alt = `Capa do livro ${book.name}`;
                    img.onerror = () => img.src = getGenericCover(book.type); // Fallback if cover image fails

                    const title = document.createElement('p');
                    title.className = 'book-card-title';
                    title.textContent = book.name.split('.').slice(0, -1).join('.'); // Remove extension from display name

                    bookCard.appendChild(img);
                    bookCard.appendChild(title);
                    bookListContainer.appendChild(bookCard);
                });
            }
        }

        /**
         * Retorna uma URL de dados para uma capa genérica baseada no tipo de arquivo.
         * @param {string} fileType - O tipo MIME do arquivo.
         * @returns {string} URL de dados da imagem ou ícone SVG.
         */
        function getGenericCover(fileType) {
            let iconCode = '';
            let bgColor = '#cbd5e1'; // Default gray

            if (fileType.includes('pdf')) {
                iconCode = `<i class="fas fa-file-pdf text-red-500 text-6xl"></i>`;
                bgColor = '#fee2e2'; // Light red
            } else if (fileType.includes('text')) {
                iconCode = `<i class="fas fa-file-alt text-blue-500 text-6xl"></i>`;
                bgColor = '#e0f2fe'; // Light blue
            } else if (fileType.includes('document')) { // docx
                iconCode = `<i class="fas fa-file-word text-blue-700 text-6xl"></i>`;
                bgColor = '#dbeafe'; // Lighter blue
            } else if (fileType.includes('presentation')) { // pptx
                iconCode = `<i class="fas fa-file-powerpoint text-orange-600 text-6xl"></i>`;
                bgColor = '#fff7ed'; // Light orange
            } else {
                iconCode = `<i class="fas fa-file text-gray-500 text-6xl"></i>`;
            }

            // Create a simple SVG icon as a data URL for covers
            const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="100" height="140" viewBox="0 0 100 140" fill="${bgColor}" class="rounded-lg">
                <rect width="100" height="140" fill="${bgColor}" rx="10"/>
                <foreignObject x="0" y="0" width="100" height="140">
                    <div xmlns="http://www.w3.org/1999/xhtml" style="display: flex; justify-content: center; align-items: center; width: 100%; height: 100%;">
                        ${iconCode}
                    </div>
                </foreignObject>
            </svg>`;
            return `data:image/svg+xml;base64,${btoa(svg)}`;
        }


        /**
         * Gera uma miniatura da primeira página de um PDF para a capa.
         * @param {string} base64Pdf - O conteúdo do PDF em Base64.
         * @returns {Promise<string|null>} URL de dados da miniatura ou null em caso de erro.
         */
        async function createPdfCoverThumbnail(base64Pdf) {
            try {
                const pdfData = atob(base64Pdf);
                const pdfBytes = new Uint8Array(pdfData.length);
                for (let i = 0; i < pdfData.length; i++) {
                    pdfBytes[i] = pdfData.charCodeAt(i);
                }

                const tempPdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
                const firstPage = await tempPdfDoc.getPage(1);
                const viewport = firstPage.getViewport({ scale: 0.5 }); // Smaller scale for thumbnail

                const thumbnailCanvas = document.createElement('canvas');
                const thumbnailContext = thumbnailCanvas.getContext('2d');
                thumbnailCanvas.height = viewport.height;
                thumbnailCanvas.width = viewport.width;

                const renderContext = {
                    canvasContext: thumbnailContext,
                    viewport: viewport,
                };
                await firstPage.render(renderContext).promise;
                return thumbnailCanvas.toDataURL('image/png');
            } catch (error) {
                console.error('Erro ao gerar capa do PDF:', error);
                return null; // Return null if thumbnail generation fails
            }
        }

        /**
         * Adiciona um novo livro à biblioteca.
         * @param {File} file - O objeto File do livro.
         */
        async function addBook(file) {
            showAppLoading();
            try {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    const dataURL = e.target.result;
                    const base64Content = dataURL.split(',')[1];
                    const bookType = file.type;
                    let bookCover = null;

                    if (bookType.includes('pdf')) {
                        bookCover = await createPdfCoverThumbnail(base64Content);
                    } else {
                        bookCover = getGenericCover(bookType); // Use generic icon for other types
                    }

                    const newBook = {
                        id: generateUUID(),
                        name: file.name,
                        type: bookType,
                        base64Content: base64Content,
                        currentPage: 1, // Start at page 1 for new books
                        cover: bookCover // Store the generated/generic cover
                    };

                    books.push(newBook);
                    saveBooksToLocalStorage();
                    renderLibrary();
                    hideAppLoading();
                    showMessage(`"${file.name}" adicionado à biblioteca!`);
                };

                // Read file as Data URL to get Base64 content
                reader.readAsDataURL(file);

            } catch (error) {
                console.error("Erro ao adicionar livro:", error);
                hideAppLoading();
                showMessage('Erro ao adicionar o livro. Tente novamente.', true);
            }
        }

        /**
         * Carrega um livro específico na tela do leitor.
         * @param {string} bookId - O ID do livro a ser carregado.
         */
        async function loadBook(bookId) {
            currentBook = books.find(b => b.id === bookId);
            if (!currentBook) {
                showMessage('Livro não encontrado.', true);
                return;
            }

            // Show reader view and hide library view
            libraryView.style.display = 'none';
            readerView.style.display = 'flex'; // Set display to flex before transition
            // Trigger transition by adding class after display update
            requestAnimationFrame(() => {
                readerView.classList.add('active');
            });


            currentBookTitleDisplay.textContent = currentBook.name;
            pdfCanvas.classList.add('hidden'); // Hide canvas by default
            textContentDisplay.classList.add('hidden'); // Hide text display by default

            if (currentBook.type.includes('pdf')) {
                pdfCanvas.classList.remove('hidden');
                pdfDoc = null; // Reset PDF doc for new book
                currentBook.currentPage = currentBook.currentPage || 1; // Ensure current page exists
                await renderPdf(currentBook.base64Content, currentBook.currentPage);
                // Enable controls for PDF
                prevPageBtn.disabled = false;
                nextPageBtn.disabled = false;
            } else if (currentBook.type.includes('text')) {
                textContentDisplay.classList.remove('hidden');
                textContentDisplay.textContent = atob(currentBook.base64Content); // Decode Base64 text
                pdfDoc = null; // No PDF doc for text files
                currentBook.currentPage = 1; // Text files usually treated as one long page or scrolled
                pageInfo.textContent = 'Texto'; // No page numbers for text files
                // Disable controls for text files as scrolling handles pagination
                prevPageBtn.disabled = true;
                nextPageBtn.disabled = true;
            } else {
                // For unsupported types (DOCX, PPTX)
                pdfCanvas.classList.remove('hidden'); // Show canvas as a placeholder for message
                const ctx = pdfCanvas.getContext('2d');
                ctx.clearRect(0, 0, pdfCanvas.width, pdfCanvas.height);
                ctx.font = '16px Inter';
                ctx.fillStyle = '#6b7280';
                ctx.textAlign = 'center';
                ctx.fillText(`Conteúdo de "${currentBook.name}"`, pdfCanvas.width / 2, pdfCanvas.height / 2 - 20);
                ctx.fillText(`não pode ser lido diretamente neste app.`, pdfCanvas.width / 2, pdfCanvas.height / 2);
                pdfDoc = null;
                pageInfo.textContent = 'Indisponível';
                prevPageBtn.disabled = true;
                nextPageBtn.disabled = true;
                showMessage(`Formato "${currentBook.type.split('/')[1]}" não suportado para leitura.`, true);
            }
            saveBooksToLocalStorage(); // Save updated current page/status
        }


        /**
         * Renderiza um documento PDF no canvas.
         * @param {string} base64Pdf - O conteúdo Base64 do PDF.
         * @param {number} pageNum - A página a ser renderizada inicialmente.
         */
        async function renderPdf(base64Pdf, pageNum) {
            showPageLoading();
            try {
                const pdfData = atob(base64Pdf);
                const pdfBytes = new Uint8Array(pdfData.length);
                for (let i = 0; i < pdfData.length; i++) {
                    pdfBytes[i] = pdfData.charCodeAt(i);
                }
                pdfDoc = await pdfjsLib.getDocument({ data: pdfBytes }).promise;
                // Set current page to loaded page, or 1 if invalid
                currentBook.currentPage = Math.max(1, Math.min(pageNum, pdfDoc.numPages));
                await renderPage(currentBook.currentPage);
                hidePageLoading();
            } catch (error) {
                console.error('Erro ao carregar o PDF:', error);
                showMessage('Erro ao carregar o PDF. Por favor, tente um arquivo válido.', true);
                pdfDoc = null;
                hidePageLoading();
                // Go back to library on critical error
                backToLibrary();
            }
        }

        /**
         * Renderiza uma página específica do PDF no canvas.
         * @param {number} pageNum - O número da página a ser renderizada.
         */
        async function renderPage(pageNum) {
            if (!pdfDoc) {
                showMessage('Nenhum documento PDF carregado.', true);
                return;
            }
            if (pageNum < 1 || pageNum > pdfDoc.numPages) {
                return; // Page number out of bounds, do nothing
            }

            // Ensure only one rendering operation is active at a time
            if (lastRenderPromise) {
                try {
                    await lastRenderPromise;
                } catch (e) { /* Ignore errors from previous renders if they were aborted/failed */ }
            }

            const renderPromise = new Promise(async (resolve, reject) => {
                try {
                    showPageLoading();
                    const page = await pdfDoc.getPage(pageNum);
                    const viewport = page.getViewport({ scale: pdfCanvas.clientWidth / page.getViewport({ scale: 1 }).width }); // Fit to canvas width
                    const context = pdfCanvas.getContext('2d');

                    // Set canvas dimensions to match the viewport
                    pdfCanvas.height = viewport.height;
                    pdfCanvas.width = viewport.width;

                    const renderContext = {
                        canvasContext: context,
                        viewport: viewport,
                    };

                    await page.render(renderContext).promise;
                    currentBook.currentPage = pageNum;
                    pageNumSpan.textContent = `${currentBook.currentPage} / ${pdfDoc.numPages}`;
                    saveBooksToLocalStorage(); // Save current page for this book
                    hidePageLoading();
                    resolve();
                } catch (error) {
                    console.error('Erro ao renderizar a página:', error);
                    showMessage('Erro ao renderizar a página.', true);
                    hidePageLoading();
                    reject(error);
                }
            });

            lastRenderPromise = renderPromise;
        }

        /**
         * Volta para a tela da biblioteca.
         */
        function backToLibrary() {
            readerView.classList.remove('active');
            // Hide reader view completely after transition
            readerView.addEventListener('transitionend', function handler() {
                readerView.style.display = 'none';
                libraryView.style.display = 'flex'; // Show library view
                readerView.removeEventListener('transitionend', handler);
            });
            currentBook = null; // Clear current book
            pdfDoc = null; // Clear PDF document
        }

        // --- Event Listeners ---

        /**
         * Evento para adicionar um novo livro.
         */
        pdfUpload.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                // Basic validation for allowed types
                const allowedTypes = ['application/pdf', 'text/plain', 'application/vnd.openxmlformats-officedocument.wordprocessingml.document', 'application/vnd.openxmlformats-officedocument.presentationml.presentation'];
                if (allowedTypes.includes(file.type)) {
                    addBook(file);
                } else {
                    showMessage(`Tipo de arquivo "${file.type}" não suportado para importação.`, true);
                }
            }
        });

        /**
         * Evento para o botão "Voltar para a Biblioteca".
         */
        backToLibraryBtn.addEventListener('click', backToLibrary);

        /**
         * Evento para o botão "Página Anterior".
         */
        prevPageBtn.addEventListener('click', () => {
            if (currentBook && currentBook.type.includes('pdf')) {
                renderPage(currentBook.currentPage - 1);
            }
        });

        /**
         * Evento para o botão "Próxima Página".
         */
        nextPageBtn.addEventListener('click', () => {
            if (currentBook && currentBook.type.includes('pdf')) {
                renderPage(currentBook.currentPage + 1);
            }
        });

        // --- Dragging for Page Turn (Arrastar para Virar Página) ---

        /**
         * Inicia o arraste quando o mouse é pressionado no canvas.
         */
        pdfCanvas.addEventListener('mousedown', (e) => {
            if (currentBook && !currentBook.type.includes('pdf')) return; // Only for PDFs
            isDragging = true;
            startX = e.clientX;
            pdfCanvas.style.cursor = 'grabbing';
            pdfCanvas.style.transition = 'none'; // Desabilita a transição durante o arraste
        });

        /**
         * Move o canvas enquanto arrasta para dar feedback visual.
         */
        pdfCanvas.addEventListener('mousemove', (e) => {
            if (!isDragging || !pdfDoc) return;
            const dx = e.clientX - startX;
            // Aplica uma leve translação horizontal para dar feedback durante o arraste
            pdfCanvas.style.transform = `translateX(${dx}px)`;
        });

        /**
         * Finaliza o arraste e decide se vira a página com base no deslocamento.
         */
        pdfCanvas.addEventListener('mouseup', (e) => {
            if (!isDragging || !pdfDoc) return;
            isDragging = false;
            pdfCanvas.style.cursor = 'grab';
            pdfCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out'; // Reabilita a transição

            const endX = e.clientX;
            const dx = endX - startX;

            if (Math.abs(dx) > dragThreshold) {
                // Se arrastado significativamente
                if (dx < 0) { // Arrastado para a esquerda (próxima página)
                    if (currentBook.currentPage < pdfDoc.numPages) {
                        // Apply animation for next page
                        pdfCanvas.style.transform = `translateX(-100%) scale(0.95)`;
                        pdfCanvas.style.opacity = '0';
                        setTimeout(() => {
                            renderPage(currentBook.currentPage + 1).then(() => {
                                pdfCanvas.style.transform = `translateX(0) scale(1)`;
                                pdfCanvas.style.opacity = '1';
                            });
                        }, 300); // Wait for the transition to complete
                    } else {
                        // Snap back if no next page
                        pdfCanvas.style.transform = `translateX(0)`;
                        showMessage('Você está na última página.', false);
                    }
                } else { // Arrastado para a direita (página anterior)
                    if (currentBook.currentPage > 1) {
                        // Apply animation for previous page
                        pdfCanvas.style.transform = `translateX(100%) scale(0.95)`;
                        pdfCanvas.style.opacity = '0';
                        setTimeout(() => {
                            renderPage(currentBook.currentPage - 1).then(() => {
                                pdfCanvas.style.transform = `translateX(0) scale(1)`;
                                pdfCanvas.style.opacity = '1';
                            });
                        }, 300); // Wait for the transition to complete
                    } else {
                        // Snap back if no previous page
                        pdfCanvas.style.transform = `translateX(0)`;
                        showMessage('Você está na primeira página.', false);
                    }
                }
            } else {
                // Snap back if not enough drag
                pdfCanvas.style.transform = `translateX(0)`;
            }
        });

        /**
         * Reseta o arraste se o mouse sair do canvas enquanto arrasta.
         */
        pdfCanvas.addEventListener('mouseleave', () => {
            // Reset if mouse leaves while dragging (important for preventing stuck states)
            if (isDragging) {
                isDragging = false;
                pdfCanvas.style.cursor = 'grab';
                pdfCanvas.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
                pdfCanvas.style.transform = `translateX(0)`;
            }
        });

        // --- Initial Load ---
        window.onload = loadBooksFromLocalStorage;

    </script>
</body>
</html>
